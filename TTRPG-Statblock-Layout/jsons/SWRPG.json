{"blocks":[{"type":"inline","id":"e85988ba5b59","properties":[],"hasRule":true,"nested":[{"type":"group","id":"2b683b8b88c9","properties":["name","size","type","subtype","alignment"],"nested":[{"type":"heading","id":"88b988282859","properties":["name"],"conditioned":true,"size":1},{"type":"subheading","id":"29cb485a6aab","properties":["type","qty"],"conditioned":true,"fallback":"-","separator":" "},{"type":"property","id":"cb2b1bcbd988","properties":["desc"],"fallback":"-","display":"","conditioned":true,"markdown":true,"callback":"output = monster.desc.italics()\nreturn output\n"}],"conditioned":true},{"type":"image","id":"c8bae969e9bb","properties":["image"]}]},{"type":"group","id":"0bf81969baeb","properties":[],"nested":[{"type":"table","id":"ea9aa80b883b","properties":["stats"],"headers":["BRA","AGI","INT","CUN","WIL","PRE"],"calculate":false,"fallback":"-","conditioned":false,"hasRule":false},{"type":"property","id":"7a1a993b6838","properties":[],"fallback":"-","hasRule":true,"callback":"let output = \"<div style=\\\"text-align: center; position:relative; top:-10px;\\\">\";\nlet stat = \"\";\nlet names = {\n    \"soak\" : \"Soak\",\n    \"wounds\" : \"Wounds\",\n    \"strain\" : \"Strain\",\n    \"mdef\" : \"M Def\",\n    \"rdef\" : \"R Def\",\n};\nconst separator = \"&nbsp;&nbsp;<strong>|</strong>&nbsp;&nbsp;\"\n\nconst isMinion = String(monster.type).localeCompare(\"minion\", undefined, { sensitivity: 'accent'}) === 0;\nconst isRival = String(monster.type).localeCompare(\"rival\", undefined, { sensitivity: 'accent'}) === 0;\n\nlet statDisplay = (targetStat) => {\n    let stat = \"\";\n    if (targetStat == undefined || targetStat in monster === false) {\n        return \"\";\n    }\n    stat = monster[targetStat]\n    if (isMinion && names[targetStat] == \"Wounds\") {\n        // Minion wounds are dependent on the quantity\n        stat *= monster.qty\n    }\n    let name = names[targetStat];\n    return `<strong>${name}</strong> : ${stat}`;\n};\n\noutput += statDisplay(\"soak\") + separator;\noutput += statDisplay(\"wounds\");\nif(!isMinion && !isRival) {\n    output += separator + statDisplay(\"strain\");\n}\noutput += \"<br>&nbsp;\";\noutput += statDisplay(\"mdef\") + separator + statDisplay(\"rdef\") + \"<br>\";\noutput += \"</div>\";\nreturn output.trim();\n\n","markdown":true,"display":"","conditioned":false,"dice":false},{"type":"property","id":"a88bdab83b9a","properties":[""],"fallback":"-","callback":"// Change these to match whatever tag you're using for Ability (green) and Proficiency (yellow) dice.\nlet abilityDiceTag = \"#Ability\"\nlet proficiencyDiceTag = \"#Proficiency\";\n\nconst characteristics = {\n    Brawn       : { name: \"Brawn\",      stat: monster.stats[0], abbrev: \"BRA\" },\n    Agility     : { name: \"Agility\",    stat: monster.stats[1], abbrev: \"AGI\" },\n    Intellect   : { name: \"Intellect\",  stat: monster.stats[2], abbrev: \"INT\" },\n    Cunning     : { name: \"Cunning\",    stat: monster.stats[3], abbrev: \"CUN\" },\n    Willpower   : { name: \"WillPower\",  stat: monster.stats[4], abbrev: \"WIL\" },\n    Presence    : { name: \"Presence\",   stat: monster.stats[5], abbrev: \"PRE\" },\n};\n\n/**\n * This maps skills in the game.  Add skills to this map and include what characteristic the skill uses.\n * This will allow dice calculations to be automatic.\n * \n * Format is: \n *   <key> : { name: <skill name>, characteristic: <skill characteristic> }\n * \n * key : lowercase value that you use in statblocks to identify the skill\n * name : the name we'll render in the output\n * characteristic : reference to the characteristics above so we can find the correct stat value\n * Skill names can be adjusted for your install, I have each skill with its own page so the links allow easy reference.\n */\nconst skills = {\n    \"astrogation\"       : { name: \"[[Astrogation]]\",            characteristic : characteristics.Intellect, },       \n    \"athletics\"         : { name: \"[[Athletics]]\",              characteristic : characteristics.Brawn, },\n    \"brawl\"             : { name: \"[[Brawl]]\",                  characteristic : characteristics.Brawn, },\n    \"charm\"             : { name: \"[[Charm]]\",                  characteristic : characteristics.Presence, },\n    \"coercion\"          : { name: \"[[Coercion]]\",               characteristic : characteristics.Willpower, },\n    \"computers\"         : { name: \"[[Computers]]\",              characteristic : characteristics.Intellect, },\n    \"cool\"              : { name: \"[[Cool]]\",                   characteristic : characteristics.Presence, },\n    \"coordination\"      : { name: \"[[Coordination]]\",           characteristic : characteristics.Agility, },\n    \"coreworlds\"        : { name: \"[[Core Worlds]]\",            characteristic : characteristics.Intellect, },\n    \"cybernetics\"       : { name: \"[[Cybernetics]]\",            characteristic : characteristics.Intellect, },  \n    \"deception\"         : { name: \"[[Deception]]\",              characteristic : characteristics.Cunning, },\n    \"discipline\"        : { name: \"[[Discipline]]\",             characteristic : characteristics.Willpower, },\n    \"education\"         : { name: \"[[Education]]\",              characteristic : characteristics.Intellect, },\n    \"gunnery\"           : { name: \"[[Gunnery]]\",                characteristic : characteristics.Agility, },\n    \"leadership\"        : { name: \"[[Leadership]]\",             characteristic : characteristics.Presence, },\n    \"lightsaber\"        : { name: \"[[Lightsaber]]\",             characteristic : characteristics.Brawn, },\n    \"lore\"              : { name: \"[[Lore]]\",                   characteristic : characteristics.Intellect, },\n    \"mechanics\"         : { name: \"[[Mechanics]]\",              characteristic : characteristics.Intellect, },\n    \"medicine\"          : { name: \"[[Medicine]]\",               characteristic : characteristics.Intellect, },\n    \"melee\"             : { name: \"[[Melee]]\",                  characteristic : characteristics.Brawn, },\n    \"negotiation\"       : { name: \"[[Negotiation]]\",            characteristic : characteristics.Presence, },\n    \"outerrim\"          : { name: \"[[Outer Rim]]\",              characteristic : characteristics.Intellect, },\n    \"perception\"        : { name: \"[[Perception]]\",             characteristic : characteristics.Cunning, },\n    \"pilotingplanetary\" : { name: \"[[Piloting (Planetary)]]\",   characteristic : characteristics.Agility, },\n    \"pilotingspace\"     : { name: \"[[Piloting (Space)]]\",       characteristic : characteristics.Agility, },\n    \"rangedheavy\"       : { name: \"[[Ranged (Heavy)]]\",         characteristic : characteristics.Agility, },\n    \"rangedlight\"       : { name: \"[[Ranged (Light)]]\",         characteristic : characteristics.Agility, },\n    \"resilience\"        : { name: \"[[Resilience]]\",             characteristic : characteristics.Brawn, },\n    \"skulduggery\"       : { name: \"[[Skulduggery]]\",            characteristic : characteristics.Cunning, },\n    \"stealth\"           : { name: \"[[Stealth]]\",                characteristic : characteristics.Agility, },\n    \"streetwise\"        : { name: \"[[Streetwise]]\",             characteristic : characteristics.Cunning, },\n    \"survival\"          : { name: \"[[Survival]]\",               characteristic : characteristics.Cunning, },\n    \"underworld\"        : { name: \"[[Underworld]]\",             characteristic : characteristics.Intellect, },\n    \"vigilance\"         : { name: \"[[Vigilance]]\",              characteristic : characteristics.Willpower, },\n    \"warfare\"           : { name: \"[[Warfare]]\",                characteristic : characteristics.Intellect, },\n    \"xenology\"          : { name: \"[[Xenology]]\",               characteristic : characteristics.Intellect, },\n};\n\n\nlet output = \"\";  // this is what we're writing html into\n\n// convenience to identify if the current monster is a minion type or not\nconst isMinion = String(monster.type).localeCompare(\"minion\", undefined, { sensitivity: 'accent'}) === 0;\nconst skillList = []; // we'll push skills into this list and sort prior to presentation\n\nif (monster.skills !== undefined && monster.skills.length != 0) {\n    monster.skills.forEach(element => { \n\n        let skill = getSkillData(element);\n        // strip out empty skill elements; this seems to be messing up the sorting\n        if (skill.label === undefined || skill.label === \"\") return;\n        skillList.push(skill);\n    });   \n\n    // sort the skills alphabetically\n    skillList.sort((a, b) => {\n        // trim out the wiki link characters\n        const labelA = /[^\\[\\]]+/.exec(a.label.toLowerCase());\n        const labelB = /[^\\[\\]]+/.exec(b.label.toLowerCase());\n        if (labelA < labelB) {\n            return -1;\n        }\n        if (labelA > labelB) {\n            return 1;\n        }\n        return 0;\n    });\n\n    // there's an annoying space on the first line, since I can't figure out how to \n    // get rid of it add an &nbsp; to every line *after* the first\n    let skillCount = 0;\n    skillList.forEach(element => {\n        let result = \"\";\n        if (element.label === undefined || element.label === \"\") {\n            // empty label, skip it\n            return;\n        }\n        if (skillCount++ > 0) {\n            output += \"&nbsp;\"\n        }\n        // minions don't have ranks, so don't output them\n        let rankString = isMinion ? `` : `${element.ranks}`;\n        // build the dice pool\n        let dicePool = proficiencyDiceTag.repeat(element.proficiency) + abilityDiceTag.repeat(element.ability);\n        // rendered output\n        output += `<strong>${element.label}</strong>: ${rankString} ( ${dicePool} )<br>`;\n    });\n}\n\nreturn output.trim();\n\n/**\n * Looks up skill labels, checks if this is a minion and returns the appropriate Proficiency and Ability dice.\n * Format of the return is an object of prototype: \n *   key : the key to lookup the skill\n *   label : the label to render the skill name\n *   charactersitic : the characteristic name the skill uses\n *   charAbbrev : abbreviated characteristic name\n *   ranks : ranks in the skill\n *   proficiency : number of proficiency dice\n *   ability : number of ability dice\n * NOTE: if the skill name is not found in the skills list we'll still render the skill, but can't trust the dice\n *       output as we don't know what characteristic to use for it\n * @param skillEntry - expected to be { name : ranks } where name is string and ranks is integer.  \n * @returns an object with the Skill Label, characteristic, Ranks, Proficiency, and Ability dice counts.\n */\nfunction getSkillData(skillEntry) {\n    let result = {\n        key : \"\",               // the key to lookup the skill\n        label : \"\",             // the label to render the skill name\n        characteristic : \"\",    // the characteristic name the skill uses\n        charAbbrev : \"\",        // abbreviated characteristic name\n        ranks : 0,              // ranks in the skill\n        proficiency : 0,        // number of proficiency dice\n        ability : 0,            // number of ability dice\n    };\n\n    let skillCharRating = 0;    // the numeric value of the characteristic\n\n    // parameter checking\n    if (!skillEntry) {\n        // an empty element - probably bad data but let's return something rather than crash\n        result.label = \"\";\n        return result;\n    }\n\n    if (typeof skillEntry === 'string') {\n        // we have a key but no value, so set ranks to 0\n        result.key = skillEntry;\n    } else if (typeof skillEntry === 'object' && skillEntry !== null && Object.keys(skillEntry).length === 1) {\n        // we have key : value\n        result.key = Object.keys(skillEntry)[0];\n        result.ranks = skillEntry[result.key];\n    } else {\n        // we have some other type of object.  Log it and bail\n        console.log('Input is neither string nor object with single key-value pair.');\n    }\n\n    // check if this is a Minion; Minion ranks ignore the text and are based on group size - 1, max of 5\n    if(isMinion) {\n        result.ranks = Math.min(5, monster.qty - 1);\n    }\n\n    // now look up the skill so we can get the characteristic\n    let skill = skills[result.key.toLowerCase()];\n    if (skill) {\n        result.label = skill.name;\n        result.characteristic = skill.characteristic.name;\n        skillCharRating = skill.characteristic.stat;  \n        result.charAbbrev = skill.characteristic.abbrev;\n    } else {\n        // we don't have an entry in the skillMap.  Just return the item key but make it obvious we don't know if the data is valid\n        // this is important - we can't find the attribute for this skill\n        result.label = \"_Unknown (\" + result.key + \")\";\n    }\n\n    // finally, set the ability and proficiency dice\n    result.ability = Math.max(skillCharRating, result.ranks) - Math.min(skillCharRating, result.ranks);\n    result.proficiency = Math.min(skillCharRating, result.ranks);\n    result.ranks = result.ranks;\n    \n    return result;\n}\n\n","markdown":true,"hasRule":true,"display":""},{"type":"traits","id":"c9db0a6b7ba8","properties":["talents"],"fallback":"-","heading":"Talents","subheadingText":"","hasRule":false,"markdown":true,"conditioned":true,"headingProp":false},{"type":"traits","id":"c8ca58e88939","properties":["abilities"],"fallback":"-","conditioned":true,"heading":"Abilities","hasRule":false,"markdown":true},{"type":"traits","id":"fbdb9a7bf869","properties":["equipment"],"fallback":"-","heading":"Equipment","conditioned":true,"hasRule":false,"markdown":true,"dice":false}]}],"name":"SWRPG","id":"180a8a3b494b"}